/**
 * Export System module
 * Outputs patch notes in multiple formats (Markdown, HTML, JSON)
 */

import type { PatchNote, ExportOptions, ExportResult } from '../../shared/types.js';
import { marked } from 'marked';
import { ErrorHandler } from './error-handler.js';

/**
 * ExportSystem class for exporting patch notes in various formats
 */
export class ExportSystem {
  /**
   * Exports a patch note to Markdown format
   * @param patchNote - The patch note to export
   * @returns Export result with Markdown content
   */
  exportMarkdown(patchNote: PatchNote): ExportResult {
    try {
      let markdown = '';

      // Add title with version and date
      markdown += `# Patch Notes ${patchNote.version}\n\n`;
      markdown += `*Released: ${patchNote.date.toLocaleDateString()}*\n\n`;
      markdown += '---\n\n';

      // Add each section
      for (const section of patchNote.sections) {
        markdown += `## ${section.title}\n\n`;

        for (const entry of section.entries) {
          // Add themed version
          markdown += `- **${entry.themed}**\n`;
          // Add original commit message as sub-item
          markdown += `  - *Original: ${entry.original}*\n`;
          markdown += `  - *Commit: \`${entry.commitHash.substring(0, 7)}\`*\n`;
        }

        markdown += '\n';
      }

      // Add footer
      markdown += '---\n\n';
      markdown += `*Generated by Phantom Patch Notes*\n`;

      return {
        content: markdown,
        mimeType: 'text/markdown',
        filename: `patch-notes-${patchNote.version}.md`
      };
    } catch (error) {
      throw ErrorHandler.handle(error, 'ExportSystem', { 
        format: 'markdown',
        version: patchNote.version,
        operation: 'exportMarkdown' 
      });
    }
  }

  /**
   * Exports a patch note to HTML format with embedded CSS
   * @param patchNote - The patch note to export
   * @param includeStyles - Whether to include embedded CSS styling
   * @returns Export result with HTML content
   */
  exportHTML(patchNote: PatchNote, includeStyles: boolean = true): ExportResult {
    try {
      // First generate Markdown
      const markdownResult = this.exportMarkdown(patchNote);
      
      // Convert Markdown to HTML
      const htmlBody = marked(markdownResult.content);

      // Build complete HTML document
      let html = '<!DOCTYPE html>\n';
      html += '<html lang="en">\n';
      html += '<head>\n';
      html += '  <meta charset="UTF-8">\n';
      html += '  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n';
      html += `  <title>Patch Notes ${patchNote.version}</title>\n`;

      if (includeStyles) {
        html += '  <style>\n';
        html += this.getHorrorThemedCSS();
        html += '  </style>\n';
      }

      html += '</head>\n';
      html += '<body>\n';
      html += '  <div class="container">\n';
      html += htmlBody;
      html += '  </div>\n';
      html += '</body>\n';
      html += '</html>\n';

      return {
        content: html,
        mimeType: 'text/html',
        filename: `patch-notes-${patchNote.version}.html`
      };
    } catch (error) {
      throw ErrorHandler.handle(error, 'ExportSystem', { 
        format: 'html',
        version: patchNote.version,
        includeStyles,
        operation: 'exportHTML' 
      });
    }
  }

  /**
   * Returns horror-themed CSS styling
   * @returns CSS string
   */
  private getHorrorThemedCSS(): string {
    return `
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
      color: #e0d0d0;
      font-family: 'Georgia', 'Times New Roman', serif;
      line-height: 1.6;
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: rgba(20, 10, 20, 0.8);
      padding: 3rem;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(139, 0, 139, 0.3);
      border: 1px solid rgba(139, 0, 139, 0.2);
    }

    h1 {
      color: #b8860b;
      font-size: 2.5rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 10px rgba(184, 134, 11, 0.5);
      font-weight: 700;
      letter-spacing: 2px;
    }

    h2 {
      color: #8b008b;
      font-size: 1.8rem;
      margin-top: 2rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 8px rgba(139, 0, 139, 0.4);
      border-bottom: 2px solid rgba(139, 0, 139, 0.3);
      padding-bottom: 0.5rem;
    }

    hr {
      border: none;
      border-top: 1px solid rgba(139, 0, 139, 0.3);
      margin: 2rem 0;
    }

    em {
      color: #a0a0a0;
      font-style: italic;
    }

    ul {
      list-style: none;
      padding-left: 0;
    }

    li {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      position: relative;
    }

    li::before {
      content: 'â˜ ';
      position: absolute;
      left: 0;
      color: #8b008b;
      font-size: 1.2rem;
    }

    strong {
      color: #d4af37;
      font-weight: 600;
    }

    code {
      background: rgba(139, 0, 139, 0.1);
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      color: #b8860b;
      font-size: 0.9rem;
    }

    a {
      color: #8b008b;
      text-decoration: none;
      transition: color 0.3s ease;
    }

    a:hover {
      color: #b8860b;
      text-shadow: 0 0 5px rgba(184, 134, 11, 0.5);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .container {
      animation: fadeIn 0.8s ease-out;
    }
    `;
  }

  /**
   * Exports a patch note to JSON format
   * @param patchNote - The patch note to export
   * @param pretty - Whether to pretty-print the JSON
   * @returns Export result with JSON content
   */
  exportJSON(patchNote: PatchNote, pretty: boolean = false): ExportResult {
    try {
      const json = pretty 
        ? JSON.stringify(patchNote, null, 2)
        : JSON.stringify(patchNote);

      return {
        content: json,
        mimeType: 'application/json',
        filename: `patch-notes-${patchNote.version}.json`
      };
    } catch (error) {
      throw ErrorHandler.handle(error, 'ExportSystem', { 
        format: 'json',
        version: patchNote.version,
        pretty,
        operation: 'exportJSON' 
      });
    }
  }

  /**
   * Unified export method that routes to appropriate exporter
   * @param patchNote - The patch note to export
   * @param options - Export options
   * @returns Export result
   */
  export(patchNote: PatchNote, options: ExportOptions): ExportResult {
    try {
      switch (options.format) {
        case 'markdown':
          return this.exportMarkdown(patchNote);
        
        case 'html':
          return this.exportHTML(patchNote, options.includeStyles ?? true);
        
        case 'json':
          return this.exportJSON(patchNote, options.pretty ?? false);
        
        default:
          throw ErrorHandler.createError(
            'INVALID_FORMAT',
            `Unsupported export format: ${options.format}`,
            'ExportSystem',
            { format: options.format, supportedFormats: ['markdown', 'html', 'json'] }
          );
      }
    } catch (error) {
      // If it's already a SystemError, re-throw it
      if (ErrorHandler.isSystemError(error)) {
        throw error;
      }
      
      throw ErrorHandler.handle(error, 'ExportSystem', { 
        format: options.format,
        version: patchNote.version,
        operation: 'export' 
      });
    }
  }
}
